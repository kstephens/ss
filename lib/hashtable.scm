;; srfi-69 basic hash tables (mostly)
(define *default-table-size* 1)

(define (make-hash-table equal hash . opts)
  (let ((length (if (null? opts) *default-table-size* (car opts))))
    (vector 'hash-table equal hash 0 (make-vector length '()))))
(define (hash-table-equal ht)  (vector-ref ht 1))
(define (hash-table-hash ht)   (vector-ref ht 2))
(define (hash-table-size ht)   (vector-ref ht 3))
(define (%hash-table-size-set! ht x) (vector-set! ht 3 x))
(define (hash-table-vector ht) (vector-ref ht 4))
(define (%hash-table-vector-set! ht x) (vector-set! ht 4 x))
(define (%hash-table-length ht) (vector-length (hash-table-vector ht)))
(define (%hash-table-entry ht key)
  (let* ((h ((hash-table-hash ht) key))
         (i (truncate-remainder h (%hash-table-length ht)))
         (slot (vector-ref (hash-table-vector ht) i))
         (entry (%asseq (hash-table-equal ht) key slot)))
    entry))
(define (hash-table-exists? ht key)
  (not (not (%hash-table-entry ht key))))
(define %hash-table-error-thunk (lambda () (error 'hash-table-not-found key)))
(define (hash-table-ref ht key . thunk)
  (set! thunk (if (pair? thunk) (car thunk) %hash-table-error-thunk))
  (let ((entry (%hash-table-entry ht key)))
    (if entry (cdr entry) (thunk))))
(define (hash-table-ref/default ht key default)
  (let ((entry (%hash-table-entry ht key)))
    (if entry (cdr entry) default)))
(define (hash-table-set! ht key value)
  (let* ((h ((hash-table-hash ht) key)))
    (hash-table-set!-hash ht key value h))
  ht)
(define (hash-table-delete! ht key)
  (let* ((h ((hash-table-hash ht) key))
         (i (truncate-remainder h (%hash-table-length ht)))
         (slot (vector-ref (hash-table-vector ht) i)))
    (if (not (null? slot))
      (if ((hash-table-equal ht) key (caar slot))
        (vector-set! (hash-table-vector ht) i (cdr slot))
        (%assrm (hash-table-equal ht) key slot))))
  ht)
(define (%assrm p x l)
  (if (pair? l)
    (if (p x (caar (cdr l)))
      (set-cdr! l (cddr l))
      (%assrm p x (cdr l)))))
(define (hash-table-set!-hash ht key value h)
  (let* ((i (truncate-remainder h (%hash-table-length ht)))
         (v (hash-table-vector ht))
         (slot (vector-ref v i))
         (entry (%asseq (hash-table-equal ht) key slot)))
    (if entry
      (set-cdr! entry value)
      (let ((new-size (+ (hash-table-size ht) 1)))
        (%hash-table-size-set! ht new-size)
        (if (>= new-size (%hash-table-length ht))
          (begin
            (hash-table-set-length! ht (+ (/ (* (%hash-table-length ht) 3) 2) 1))
            (hash-table-set!-hash ht key value h))
          (vector-set! v i (cons (cons key value) slot)))))))
(define (%asseq p x l)
  (if (null? l) #f
    (if (p x (car (car l))) (car l)
      (%asseq p x (cdr l)))))
(define (hash-table-set-length! ht length)
  (let ((old-vector (hash-table-vector ht)))
    (%hash-table-vector-set! ht (make-vector length '()))
    (%hash-table-size-set! ht 0)
    (hash-table-vector-each
      (lambda (kv)
        (hash-table-set! ht (car kv) (cdr kv))) old-vector))
  ht)
(define (hash-table-each assoc-proc ht)
  (hash-table-vector-each assoc-proc (hash-table-vector ht)))
(define (hash-table-vector-each assoc-proc v)
  (vector-each 
    (lambda (slot) (for-each assoc-proc slot))
    v))
(define (hash-table-walk ht proc)
  (hash-table-each (lambda (kv) (proc (car kv) (cdr kv))) ht))
(define (hash-table-map assoc-proc ht)
  (apply append
    (map (lambda (slot) (map assoc-proc slot)) 
      (vector->list (hash-table-vector ht)))))
(define (hash-table-keys ht)   (hash-table-map car ht))
(define (hash-table-values ht) (hash-table-map cdr ht))
(define (hash-table->alist ht) (hash-table-map %hash-table-identity ht))
(define (%hash-table-identity x) x)
(define (alist->hash-table! alist ht)
  (for-each (lambda (kv) (hash-table-set! ht (car kv) (cdr kv))) alist)
  ht)
(define (alist->hash-table alist . ht-opts)
  (alist->hash-table! alist (apply make-hash-table ht-opts)))

'hash-table
